<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>SimpleCircuitOnline</title>
    <!-- <base href="/SimpleCircuit/" /> -->
    <!-- <link href="css/bootstrap/bootstrap.min.css" rel="stylesheet" /> -->
    <link href="css/app.css" rel="stylesheet" />
    <link href="SimpleCircuitOnline.styles.css" rel="stylesheet" />
    <link href="_content/BlazorMonaco/lib/monaco-editor/min/vs/editor/editor.main.css" rel="stylesheet" />
    <style id="svg-style"></style>
</head>

<body>
    <app>
        <div class="loading-spinner" role="status">
            <span class="sr-only">Loading...</span>
        </div>
    </app>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">🗙</a>
    </div>

    <div style="position:absolute;left:-9999cm;top:-9999cm;" id="div_measure"></div>
    <canvas id="canvas" width="200" height="200" style="position:absolute;left:-9999px;top:-9999px;"></canvas>

    <script src="_content/BlazorMonaco/lib/monaco-editor/min/vs/loader.js"></script>
    <script>require.config({ paths: { 'vs': '_content/BlazorMonaco/lib/monaco-editor/min/vs' } });</script>
    <script src="_content/BlazorMonaco/lib/monaco-editor/min/vs/editor/editor.main.js"></script>
    <script src="_content/BlazorMonaco/jsInterop.js"></script>
    <script src="js/decode.min.js"></script>
    <script src="_framework/blazor.webassembly.js" autostart="false"></script>
    <script>
        function DownloadData(filename, exportUrl) {
            // Create the <a> element and click on it
            const a = document.createElement("a");
            document.body.appendChild(a);
            a.href = exportUrl;
            a.download = filename;
            a.target = "_self";
            a.click();
            document.body.removeChild(a);
        }

        // Source code copied and modified from Gérald Barré
        function BlazorDownloadFile(filename, contentType, data) {

            // Create the URL
            const file = new File([data], filename, { type: contentType });
            const exportUrl = URL.createObjectURL(file);
            DownloadData(filename, exportUrl);
            URL.revokeObjectURL(exportUrl);
        }

        function BlazorExportImage(filename, mime, imageData, width, height, backgroundColor) {

            var image = new Image();
            image.onload = () => {
                var canvas = document.getElementById("canvas");
                canvas.width = width;
                canvas.height = height;
                var context = canvas.getContext("2d");

                // Draw a background image if necessary
                if (backgroundColor) {
                    context.fillStyle = backgroundColor;
                    context.fillRect(0, 0, width, height);
                }

                // Draw the image (it has been loaded) and download the image
                context.drawImage(image, 0, 0, width, height);
                DownloadData(filename, canvas.toDataURL(mime));
            };
            image.src = imageData;
        }

        Blazor.start({
            loadBootResource: function (type, name, defaultUri, integrity) {
                // For framework resources, use the precompressed .br files for faster downloads
                // This is needed only because GitHub pages doesn't natively support Brotli (or even gzip for .dll files)
                if (type !== 'dotnetjs' && location.hostname !== 'localhost') {
                    return (async function () {
                        const response = await fetch(defaultUri + '.br', { cache: 'no-cache' });
                        if (!response.ok) {
                            throw new Error(response.statusText);
                        }
                        const originalResponseBuffer = await response.arrayBuffer();
                        const originalResponseArray = new Int8Array(originalResponseBuffer);
                        const decompressedResponseArray = BrotliDecode(originalResponseArray);
                        const contentType = type === 'dotnetwasm' ? 'application/wasm' : 'application/octet-stream';
                        return new Response(decompressedResponseArray, { headers: { 'content-type': contentType } });
                    })();
                }
            }
        });
    </script>
    <script>
        function registerLanguage(keywords) {

            // Register a new language
            monaco.languages.register({ id: 'simpleCircuit' });

            // Register a tokens provider for the language
            keywordRegex = new RegExp('\\b(?:' + keywords.join("|") + ')[\\w\\d]*\\b(?![\\.\\/])');
            sectionRegex = new RegExp('\\b\\w[\\w\\d]*\\b(?!/)');
            monaco.languages.setMonarchTokensProvider('simpleCircuit', {
                defaultToken: 'invalid',
                includeLF: true,
                tokenizer: {
                    root: [
                        { include: '@comment' },
                        [/^[\s\t]*-/, { token: 'dash.assignment', next: '@assignment' }],
                        [/^[\s\t]*\(/, { token: 'bracket.virtual', bracket: '@open', next: '@virtual' }],
                        [/^[\s\t]*\./, { token: 'dot.command', bracket: '@open', next: '@command' }],
                        { include: '@component_chain' },
                    ],
                    component_chain: [
                        { include: '@whitespace' },
                        [keywordRegex, { token: 'component.$S0' }],
                        [/\w+/, { token: 'word.$S0' }],
                        [/\//, { token: 'separator.$S0' }],
                        [/\</, { token: 'bracket.wire.$S0', bracket: '@open', next: '@wire.$S0' }],
                        [/\[/, { token: 'bracket.pin.$S0', bracket: '@open', next: '@pin_block' }],
                        [/\(/, { token: 'bracket.label.$S0', bracket: '@open', next: '@label_block' }],
                    ],
                    virtual: [
                        { include: '@component_chain' },
                        [/\)/, { token: 'bracket.$S0', bracket: '@close', next: '@pop' }],
                    ],
                    assignment: [
                        [/\n/, { token: 'newline', next: '@pop' }],
                        { include: '@whitespace' },
                        { include: '@number' },
                        { include: '@string' },
                        { include: '@boolean' },
                        [/\=/, 'equals.assignment'],
                        [/\w+/, 'word.assignment'],
                        [/\./, 'dot.assignment'],
                    ],
                    wire: [
                        { include: '@whitespace' },
                        [/\b([lurdneswa]|ne|nw|se|sw)\b/, { token: 'pindirection.$S0', log: 'wire:$S0 $S1 $S2 $S3' }],
                        [/\>/, { token: 'bracket.$S0', bracket: '@close', next: '@pop' }],
                        { include: '@number' },
                        [/\+/, { token: 'operator.$S0' }],
                    ],
                    command: [
                        [/\b\w+\b/, { token: 'word' }],
                        [/\n/, { token: 'newline', next: '@pop' }],
                    ],
                    pin_block: [
                        { include: '@whitespace' },
                        [/\w+/, { token: 'word.pin' }],
                        [/\]/, { token: 'bracket.pin', bracket: '@close', next: '@pop' }],
                    ],
                    label_block: [
                        { include: '@whitespace' },
                        [/\)/, { token: 'bracket.label', bracket: '@close', next: '@pop' }],
                        { include: '@string' },
                    ],
                    string: [
                        [/"([^"]|\\.)+"/, 'string'],
                        [/'([^']|\\.)+'/, 'string'],
                    ],
                    whitespace: [
                        [/[ \t]+/, 'white'],
                    ],
                    number: [
                        [/[-]?\d+(\.d+)?/, { token: 'number.$S0' }],
                    ],
                    boolean: [
                        [/true|false/, { token: 'boolean.$S0' }],
                    ],
                    comment: [
                        [/^[\s\t]*\/\/.*\n$/, 'comment'],
                    ],
                }
            });

            // Define a new theme that contains only rules that match this language
            monaco.editor.defineTheme('simpleCircuitTheme', {
                base: 'vs',
                inherit: true,
                rules: [
                    { token: 'word', foreground: '0000ff', fontStyle: 'bold' },
                    { token: 'word.virtual', foreground: '9999ff' },
                    { token: 'word.pin', foreground: '7a92cf' },
                    { token: 'bracket', foreground: 'ff0000' },
                    { token: 'bracket.virtual', foreground: 'ff9999' },
                    { token: 'bracket.wire', foreground: 'cc0000' },
                    { token: 'bracket.wire.virtual', foreground: 'cc9999' },
                    { token: 'bracket.pin', foreground: '7a92cf' },
                    { token: 'number', foreground: 'a0a0a0' },
                    { token: 'number.wire', foreground: 'cc6666' },
                    { token: 'number.wire.virtual', foreground: 'cc9999' },
                    { token: 'comment', foreground: '00a000' },
                    { token: 'component', foreground: '9a47ff', fontStyle: 'bold' },
                    { token: 'component.virtual', foreground: 'c799ff' },
                    { token: 'pindirection', foreground: 'cc0000' },
                    { token: 'pindirection.wire.virtual', foreground: 'cc9999' },
                    { token: 'string', foreground: 'a633f2' },
                    { token: 'operator', foreground: '660000' },
                    { token: 'operator.wire', foreground: 'cc0000' },
                    { token: 'operator.wire.virtual', foreground: '996666' },
                    { token: 'equals', foreground: 'cc0000', fontStyle: 'bold' },
                    { token: 'dot', foreground: '0000cc' },
                    { token: 'dash', foreground: '0000cc', fontStyle: 'bold' },
                    { token: 'word.assignment', foreground: '990000', fontStyle: 'bold' },
                    { token: 'dot.assignment', foreground: '666666' },
                    { token: 'equals.assignment', foreground: '666666' },
                    { token: 'boolean', foreground: 'a0a0a0' },
                    { token: 'separator', foreground: '0000ff' },
                ]
            });

            monaco.languages.registerCompletionItemProvider('simpleCircuit', {
                provideCompletionItems: (model, position) => {
                    const word = model.getWordUntilPosition(position);
                    const range = {
                        startLineNumber: position.lineNumber,
                        endLineNumber: position.lineNumber,
                        startColumn: word.startColumn,
                        endColumn: word.endColumn
                    };
                    var suggestions = [];
                    for (var i = 0; i < keywords.length; i++) {
                        keyword = keywords[i];
                        if (keyword[0].startsWith(word.word.toUpperCase())) {
                            suggestions.push({
                                label: keyword[0],
                                insertText: keyword[0],
                                detail: keyword[1],
                                range: range
                            });
                        }
                    }

                    return {
                        suggestions: suggestions
                    }
                }
            });
        }

        function calculateBounds(element) {
            var div_measure = document.getElementById('div_measure');

            // We simply parse the XML and return the bounds
            var parser = new DOMParser();
            var e = parser.parseFromString(element, "image/svg+xml").documentElement;
            div_measure.appendChild(e);
            var b = e.getBBox();
            div_measure.removeChild(e);
            return {
                x: b.x,
                y: b.y,
                width: b.width,
                height: b.height
            };
        }

        function updateStyle(style) {
            document.getElementById("svg-style").innerHTML = style;
        }
    </script>
</body>

</html>
